# Teu-Im Database Schema

Complete reference for the Teu-Im database structure, tables, relationships, and Row Level Security policies.

## Table of Contents

- [Database Overview](#database-overview)
- [Tables](#tables)
  - [Users](#users)
  - [Projects](#projects)
  - [Sessions](#sessions)
  - [Interpretations](#interpretations)
  - [Audio Chunks](#audio-chunks)
- [Relationships](#relationships)
- [Row Level Security](#row-level-security)
- [Indexes](#indexes)
- [Migrations](#migrations)
- [Backups and Recovery](#backups-and-recovery)

---

## Database Overview

The Teu-Im database is hosted on Supabase (PostgreSQL-compatible) and manages all data for interpretation projects, live sessions, transcriptions, and audio storage.

**Database Type**: PostgreSQL 15+
**Hosting**: Supabase
**Language Support**: Full Unicode support (Korean, English, Japanese, Chinese, etc.)
**Real-Time Subscriptions**: Enabled for live session updates

### Key Design Principles

1. **User Isolation**: All data partitioned by user; RLS prevents cross-user access
2. **Project Ownership**: Projects owned by users; sessions belong to projects
3. **Immutable Records**: Interpretations are append-only; corrections don't modify history
4. **Efficient Queries**: Indexes on frequently-accessed fields for fast retrieval
5. **Audit Trail**: Timestamps track creation and updates for all records

---

## Tables

### Users

Stores user account information and API key settings.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | User ID (Supabase auth.users.id) |
| `email` | TEXT | UNIQUE, NOT NULL | User email address |
| `name` | TEXT | - | User's display name (optional) |
| `soniox_api_key` | TEXT | - | Encrypted Soniox STT API key (optional) |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Account creation timestamp |

**Notes**:
- User IDs are auto-generated by Supabase Auth
- Email is unique per account
- Soniox API key stored encrypted via Supabase pgsodium extension
- User deletion cascades to projects and sessions

**Example**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "organizer@example.com",
  "name": "Park Min-jun",
  "soniox_api_key": "[encrypted]",
  "created_at": "2024-01-15T10:30:00Z"
}
```

---

### Projects

Stores interpretation project definitions with language settings and access codes.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Project ID (auto-generated) |
| `user_id` | UUID | FOREIGN KEY (users), NOT NULL | Project owner |
| `name` | TEXT | NOT NULL | Project name (1-100 chars) |
| `code` | TEXT | UNIQUE, NOT NULL | 6-character alphanumeric join code |
| `password` | TEXT | NOT NULL | 4-digit numeric password |
| `source_lang` | TEXT | NOT NULL | Source language code (e.g., "ko") |
| `target_lang` | TEXT | NOT NULL | Primary target language code (backward compat) |
| `target_langs` | TEXT[] | NOT NULL | Array of target language codes |
| `status` | TEXT | CHECK: idle/active/ended | Project status |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | DEFAULT NOW() | Last update timestamp |

**Constraints**:
- `status` can only be: `idle`, `active`, `ended`
- `code` is unique (prevent duplicate join codes)
- `source_lang` and each item in `target_langs` must be valid language codes
- `password` length 4 digits (numeric string)
- `code` length 6 characters (alphanumeric, uppercase)

**Language Codes Supported**:
```
ko (Korean), en (English), ja (Japanese), zh (Chinese),
es (Spanish), fr (French), de (German), it (Italian),
pt (Portuguese), ru (Russian), ar (Arabic), hi (Hindi),
th (Thai), vi (Vietnamese), id (Indonesian), ms (Malay),
ca (Catalan), da (Danish), el (Greek), he (Hebrew),
hu (Hungarian), lt (Lithuanian), nl (Dutch), no (Norwegian),
pl (Polish), ro (Romanian), sv (Swedish), tr (Turkish), uk (Ukrainian)
```

**Example**:
```json
{
  "id": "proj-123",
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Q4 Conference 2024",
  "code": "CONF24",
  "password": "1234",
  "source_lang": "ko",
  "target_lang": "en",
  "target_langs": ["en", "ja", "zh"],
  "status": "active",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}
```

---

### Sessions

Stores live interpretation sessions within a project.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Session ID (auto-generated) |
| `project_id` | UUID | FOREIGN KEY (projects), NOT NULL | Parent project |
| `name` | TEXT | - | Optional session name |
| `status` | TEXT | CHECK: active/paused/completed/ended | Session status |
| `audio_file_path` | TEXT | - | Supabase storage path for exported audio |
| `audio_duration_ms` | INTEGER | - | Total session duration in milliseconds |
| `started_at` | TIMESTAMPTZ | NOT NULL | Session start time |
| `ended_at` | TIMESTAMPTZ | - | Session end time (NULL if active) |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Record creation time |
| `updated_at` | TIMESTAMPTZ | DEFAULT NOW() | Last update time |

**Constraints**:
- `status` can only be: `active`, `paused`, `completed`, `ended`
- `started_at` required, cannot be in future
- `ended_at` must be >= `started_at` if provided
- Only one active session per project (enforced by application logic)
- Foreign key to projects (delete project cascades to sessions)

**Status Lifecycle**:
```
active → paused → active → completed/ended
         ↑_________________↓
```

**Example**:
```json
{
  "id": "sess-456",
  "project_id": "proj-123",
  "name": "Morning Session",
  "status": "ended",
  "audio_file_path": "sessions/sess-456/audio.wav",
  "audio_duration_ms": 1800000,
  "started_at": "2024-01-15T12:00:00Z",
  "ended_at": "2024-01-15T12:30:00Z",
  "created_at": "2024-01-15T12:00:00Z",
  "updated_at": "2024-01-15T12:30:00Z"
}
```

---

### Interpretations

Stores transcription and translation results from sessions.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Interpretation ID (auto-generated) |
| `session_id` | UUID | FOREIGN KEY (sessions), NOT NULL | Parent session |
| `original_text` | TEXT | NOT NULL | Source language text |
| `translated_text` | TEXT | NOT NULL | Target language translation |
| `target_language` | TEXT | NOT NULL | Language code of translation |
| `is_final` | BOOLEAN | DEFAULT false | Whether this is final or interim |
| `sequence` | INTEGER | NOT NULL | Order in session (1-indexed) |
| `start_time_ms` | INTEGER | - | Timestamp in session (milliseconds) |
| `end_time_ms` | INTEGER | - | End timestamp in session |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Creation timestamp |

**Constraints**:
- `sequence` unique per session (no duplicate sequences)
- `target_language` must be valid language code
- `end_time_ms` must be >= `start_time_ms` if both provided
- Timestamps relative to session start (0 = session start)

**Notes**:
- Records are append-only (never updated or deleted)
- `is_final` flag indicates confidence level
- Interim results may be overwritten in UI but retained in database for audit
- Multiple translations per sequence (one per target language)

**Example**:
```json
{
  "id": "interp-789",
  "session_id": "sess-456",
  "original_text": "안녕하세요, 회의를 시작하겠습니다.",
  "translated_text": "Hello, let me start the meeting.",
  "target_language": "en",
  "is_final": true,
  "sequence": 1,
  "start_time_ms": 0,
  "end_time_ms": 3500,
  "created_at": "2024-01-15T12:00:05Z"
}
```

---

### Audio Chunks

Stores metadata for audio file segments uploaded during sessions.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Chunk ID (auto-generated) |
| `session_id` | UUID | FOREIGN KEY (sessions), NOT NULL | Parent session |
| `chunk_index` | INTEGER | NOT NULL | Sequential chunk number (0-indexed) |
| `storage_path` | TEXT | NOT NULL | Supabase storage path |
| `start_time_ms` | INTEGER | NOT NULL | Session timestamp start |
| `end_time_ms` | INTEGER | NOT NULL | Session timestamp end |
| `duration_ms` | INTEGER | NOT NULL | Chunk duration (end - start) |
| `file_size_bytes` | INTEGER | NOT NULL | File size in bytes |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Upload timestamp |

**Constraints**:
- `chunk_index` unique per session
- `storage_path` unique (one file per chunk)
- `end_time_ms` must be > `start_time_ms`
- `duration_ms` must equal `end_time_ms - start_time_ms`
- Foreign key to sessions (delete session cascades to chunks)

**Supabase Storage Path Format**:
```
sessions/{session_id}/audio-chunk-{chunk_index}.wav
```

**Example**:
```json
{
  "id": "chunk-101",
  "session_id": "sess-456",
  "chunk_index": 0,
  "storage_path": "sessions/sess-456/audio-chunk-0.wav",
  "start_time_ms": 0,
  "end_time_ms": 5000,
  "duration_ms": 5000,
  "file_size_bytes": 160000,
  "created_at": "2024-01-15T12:00:05Z"
}
```

---

## Relationships

### Entity Relationship Diagram

```
┌──────────┐
│  Users   │ (Authentication)
└────┬─────┘
     │ user_id
     │ (1:N)
     │
     ▼
┌──────────────────┐
│  Projects        │ (Interpretation projects)
│  - code (UNIQUE) │
│  - password      │
└────┬─────────────┘
     │ project_id
     │ (1:N)
     │
     ├─────────────┬──────────────┐
     ▼             ▼              ▼
┌─────────┐  ┌──────────────────┐
│ Sessions│  │ Interpretations  │
│         │  │ - original_text  │
└────┬────┘  │ - translated     │
     │       │ - target_lang    │
     │       └──────────────────┘
     │ session_id
     │
     ▼
┌─────────────┐
│ AudioChunks │
└─────────────┘
```

### Data Flow

1. **User Creation**: Authentication via Supabase Auth creates user
2. **Project Creation**: User creates project with source/target languages
3. **Session Start**: User starts session within project
4. **Real-Time Transcription**:
   - Audio uploaded in chunks → AudioChunks table
   - STT API transcribes audio → Interpretations (interim)
   - Translations generated → Interpretations (final, is_final=true)
5. **Session End**: User ends session, final data persists

### Cascade Behavior

```
User Deletion
  ↓
  Projects (user_id)
    ↓
    Sessions (project_id)
      ├─ Interpretations (session_id) [DELETED]
      └─ AudioChunks (session_id) [DELETED]
```

---

## Row Level Security

Supabase RLS policies enforce user isolation at the database level. Users can only access their own data.

### Enabling RLS

```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE interpretations ENABLE ROW LEVEL SECURITY;
ALTER TABLE audio_chunks ENABLE ROW LEVEL SECURITY;
```

### Users Table Policies

```sql
-- Users can view only their own record
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

-- Users can update only their own record
CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE USING (auth.uid() = id);
```

### Projects Table Policies

```sql
-- Users can view only their own projects
CREATE POLICY "Users can view own projects" ON projects
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert projects only for themselves
CREATE POLICY "Users can create projects" ON projects
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update only their own projects
CREATE POLICY "Users can update own projects" ON projects
  FOR UPDATE USING (auth.uid() = user_id);

-- Users can delete only their own projects
CREATE POLICY "Users can delete own projects" ON projects
  FOR DELETE USING (auth.uid() = user_id);
```

### Sessions Table Policies

```sql
-- Users can view sessions for projects they own
CREATE POLICY "Users can view own sessions" ON sessions
  FOR SELECT USING (
    project_id IN (
      SELECT id FROM projects WHERE user_id = auth.uid()
    )
  );

-- Users can create sessions for projects they own
CREATE POLICY "Users can create sessions" ON sessions
  FOR INSERT WITH CHECK (
    project_id IN (
      SELECT id FROM projects WHERE user_id = auth.uid()
    )
  );

-- Users can update sessions for projects they own
CREATE POLICY "Users can update own sessions" ON sessions
  FOR UPDATE USING (
    project_id IN (
      SELECT id FROM projects WHERE user_id = auth.uid()
    )
  );

-- Users can delete sessions for projects they own
CREATE POLICY "Users can delete own sessions" ON sessions
  FOR DELETE USING (
    project_id IN (
      SELECT id FROM projects WHERE user_id = auth.uid()
    )
  );
```

### Interpretations Table Policies

```sql
-- Users can view interpretations for their sessions
CREATE POLICY "Users can view interpretations" ON interpretations
  FOR SELECT USING (
    session_id IN (
      SELECT s.id FROM sessions s
      JOIN projects p ON s.project_id = p.id
      WHERE p.user_id = auth.uid()
    )
  );

-- Users can insert interpretations for their sessions
CREATE POLICY "Users can create interpretations" ON interpretations
  FOR INSERT WITH CHECK (
    session_id IN (
      SELECT s.id FROM sessions s
      JOIN projects p ON s.project_id = p.id
      WHERE p.user_id = auth.uid()
    )
  );
```

### Audio Chunks Table Policies

```sql
-- Users can view audio chunks for their sessions
CREATE POLICY "Users can view audio chunks" ON audio_chunks
  FOR SELECT USING (
    session_id IN (
      SELECT s.id FROM sessions s
      JOIN projects p ON s.project_id = p.id
      WHERE p.user_id = auth.uid()
    )
  );

-- Users can insert audio chunks for their sessions
CREATE POLICY "Users can create audio chunks" ON audio_chunks
  FOR INSERT WITH CHECK (
    session_id IN (
      SELECT s.id FROM sessions s
      JOIN projects p ON s.project_id = p.id
      WHERE p.user_id = auth.uid()
    )
  );
```

### Service Role Access

The service role (used only in server-side API routes) bypasses RLS and has full database access. Use sparingly for administrative operations.

---

## Indexes

Indexes optimize query performance on frequently-accessed fields.

### Primary Indexes (Created Automatically)

```sql
-- Table primary keys (B-tree indexes)
CREATE INDEX idx_users_id ON users(id);
CREATE INDEX idx_projects_id ON projects(id);
CREATE INDEX idx_sessions_id ON sessions(id);
CREATE INDEX idx_interpretations_id ON interpretations(id);
CREATE INDEX idx_audio_chunks_id ON audio_chunks(id);
```

### Foreign Key Indexes

```sql
-- Enable fast joins
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_sessions_project_id ON sessions(project_id);
CREATE INDEX idx_interpretations_session_id ON interpretations(session_id);
CREATE INDEX idx_audio_chunks_session_id ON audio_chunks(session_id);
```

### Lookup Indexes

```sql
-- Support lookups by code/password (attendee join)
CREATE INDEX idx_projects_code ON projects(code);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_sessions_status ON sessions(status);
```

### Sequence Indexes

```sql
-- Support interpretation ordering
CREATE INDEX idx_interpretations_session_sequence ON interpretations(session_id, sequence);
CREATE INDEX idx_audio_chunks_session_index ON audio_chunks(session_id, chunk_index);
```

### Timestamp Indexes

```sql
-- Support time-range queries for analytics
CREATE INDEX idx_projects_created_at ON projects(created_at);
CREATE INDEX idx_sessions_started_at ON sessions(started_at);
CREATE INDEX idx_sessions_ended_at ON sessions(ended_at);
```

---

## Migrations

Database schema changes are managed via Supabase migrations. New tables and indexes should be version-controlled.

### Migration Workflow

1. **Create Migration**: Use Supabase CLI or dashboard
2. **Test Locally**: Apply migration to local database
3. **Version Control**: Commit migration files to Git
4. **Deploy**: Apply migration to production via Supabase

### Example Migration (SQL)

```sql
-- File: migrations/20240115_initial_schema.sql
-- Create users table
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  soniox_api_key TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create projects table
CREATE TABLE IF NOT EXISTS projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  code TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL,
  source_lang TEXT NOT NULL,
  target_lang TEXT NOT NULL,
  target_langs TEXT[] NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('idle', 'active', 'ended')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create sessions table
CREATE TABLE IF NOT EXISTS sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  name TEXT,
  status TEXT NOT NULL CHECK (status IN ('active', 'paused', 'completed', 'ended')),
  audio_file_path TEXT,
  audio_duration_ms INTEGER,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create interpretations table
CREATE TABLE IF NOT EXISTS interpretations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  original_text TEXT NOT NULL,
  translated_text TEXT NOT NULL,
  target_language TEXT NOT NULL,
  is_final BOOLEAN DEFAULT false,
  sequence INTEGER NOT NULL,
  start_time_ms INTEGER,
  end_time_ms INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(session_id, sequence)
);

-- Create audio_chunks table
CREATE TABLE IF NOT EXISTS audio_chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  storage_path TEXT NOT NULL UNIQUE,
  start_time_ms INTEGER NOT NULL,
  end_time_ms INTEGER NOT NULL,
  duration_ms INTEGER NOT NULL,
  file_size_bytes INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(session_id, chunk_index)
);

-- Create indexes
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_projects_code ON projects(code);
CREATE INDEX idx_sessions_project_id ON sessions(project_id);
CREATE INDEX idx_interpretations_session_id ON interpretations(session_id);
CREATE INDEX idx_audio_chunks_session_id ON audio_chunks(session_id);
```

### Running Migrations Locally

```bash
# Install Supabase CLI
npm install -g supabase

# Start local database
supabase start

# Apply migrations
supabase migration up

# Push to production
supabase db push
```

---

## Backups and Recovery

Supabase provides automatic backups and point-in-time recovery.

### Automatic Backups

- **Frequency**: Daily backups (configurable)
- **Retention**: 30 days (Enterprise: configurable)
- **Storage**: Redundant across multiple regions
- **Access**: Via Supabase dashboard

### Point-in-Time Recovery

Restore database to any point within retention window:

1. Go to Supabase Dashboard → Project → Database → Backups
2. Click **Restore** next to desired backup
3. Select recovery time (within retention window)
4. Confirm restore (production database restored)

### Manual Backup

Export entire database:

```bash
# Using pg_dump
pg_dump -h your-project.db.supabase.co \
    -U postgres \
    -d postgres > backup_$(date +%Y%m%d_%H%M%S).sql

# Prompt for password (find in Supabase dashboard)
```

### Recovery from Manual Backup

```bash
# Restore from backup
psql -h your-project.db.supabase.co \
    -U postgres \
    -d postgres < backup_20240115_100000.sql
```

### Backup Best Practices

- [ ] Test restores regularly
- [ ] Store backups in multiple locations
- [ ] Document backup procedures
- [ ] Schedule regular full backups
- [ ] Monitor backup completion

---

## Query Examples

### Find User's Projects

```sql
SELECT * FROM projects
WHERE user_id = 'user-id'
ORDER BY created_at DESC;
```

### Get Session with Interpretation Count

```sql
SELECT
  s.id,
  s.project_id,
  s.status,
  COUNT(i.id) AS interpretation_count,
  s.started_at,
  s.ended_at
FROM sessions s
LEFT JOIN interpretations i ON s.id = i.session_id
WHERE s.project_id = 'proj-123'
GROUP BY s.id
ORDER BY s.started_at DESC;
```

### Get Interpretations for Export

```sql
SELECT
  sequence,
  original_text,
  translated_text,
  target_language,
  start_time_ms,
  end_time_ms,
  created_at
FROM interpretations
WHERE session_id = 'sess-456'
  AND is_final = true
  AND target_language = 'en'
ORDER BY sequence ASC;
```

### Get Storage Usage by Project

```sql
SELECT
  p.id,
  p.name,
  SUM(ac.file_size_bytes) / 1024 / 1024 AS size_mb,
  COUNT(ac.id) AS chunk_count
FROM projects p
LEFT JOIN sessions s ON p.id = s.project_id
LEFT JOIN audio_chunks ac ON s.id = ac.session_id
WHERE p.user_id = 'user-id'
GROUP BY p.id, p.name
ORDER BY size_mb DESC;
```

### Find Long-Running Sessions

```sql
SELECT
  s.id,
  s.project_id,
  EXTRACT(EPOCH FROM (s.ended_at - s.started_at)) / 60 AS duration_minutes,
  COUNT(i.id) AS interpretation_count
FROM sessions s
LEFT JOIN interpretations i ON s.id = i.session_id
WHERE s.ended_at IS NOT NULL
  AND s.project_id IN (
    SELECT id FROM projects WHERE user_id = 'user-id'
  )
GROUP BY s.id
HAVING EXTRACT(EPOCH FROM (s.ended_at - s.started_at)) / 60 > 60
ORDER BY duration_minutes DESC;
```

---

## Performance Considerations

### Query Optimization

- **Use RLS filters**: Let database filter by user_id early
- **Index joins**: Ensure indexed fields used for joins
- **Limit result sets**: Use pagination for large queries
- **Denormalize when needed**: Cache counts in parent records

### Storage Optimization

- **Archive old audio**: Move audio chunks to cheaper storage after 90 days
- **Compress interpretations**: Store text efficiently
- **Prune temporary data**: Remove interim (non-final) interpretations after 7 days

### Connection Pooling

Supabase automatically manages connection pools. For high-traffic deployments:

```typescript
// Use connection pooling mode in Supabase
const supabaseUrl = 'https://your-project.supabase.co';
const supabaseKey = 'your-anon-key';

const supabase = createClient(supabaseUrl, supabaseKey, {
  realtime: {
    params: {
      eventsPerSecond: 10, // Adjust for load
    },
  },
});
```

---

## Additional Resources

- [Supabase Database Guide](https://supabase.com/docs/guides/database)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [Performance Tips](https://supabase.com/docs/guides/database/best-practices)

